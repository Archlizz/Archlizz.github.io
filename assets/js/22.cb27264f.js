(window.webpackJsonp=window.webpackJsonp||[]).push([[22],{601:function(t,e,a){"use strict";a.r(e);var n=a(1),i=Object(n.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"fox3-0-插件开发规范-android"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#fox3-0-插件开发规范-android"}},[t._v("#")]),t._v(" Fox3.0 插件开发规范(Android)")]),t._v(" "),a("p"),a("div",{staticClass:"table-of-contents"},[a("ul",[a("li",[a("a",{attrs:{href:"#前言"}},[t._v("前言")])]),a("li",[a("a",{attrs:{href:"#插件的形式"}},[t._v("插件的形式")])]),a("li",[a("a",{attrs:{href:"#插件类型"}},[t._v("插件类型")])])])]),a("p"),t._v(" "),a("h2",{attrs:{id:"前言"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#前言"}},[t._v("#")]),t._v(" 前言")]),t._v(" "),a("p",[t._v("开发规范无论怎么强调都不为过，所以我也在这里喋喋不休的重复插件开发的规范，一遍又一遍。")]),t._v(" "),a("h2",{attrs:{id:"插件的形式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#插件的形式"}},[t._v("#")]),t._v(" 插件的形式")]),t._v(" "),a("p",[t._v("插件最核心的思想是：隔离性和可插拔。在android开发中，module(aar)是比较符合插件的核心思想的。所有我们要求插件是通过module来实现。\nmoduel创建步骤：")]),t._v(" "),a("p",[t._v("步骤一：\nFile->New->New Module")]),t._v(" "),a("p",[t._v("步骤二：\n选择Android Library")]),t._v(" "),a("p",[a("img",{attrs:{src:"http://static.zybuluo.com/jiangch316/0pcfs5t2t2atf9jnwt7dnk4v/module_create.png",alt:"module_create.png-103.2kB"}})]),t._v(" "),a("p",[t._v("##插件的内容##\n插件是有代码和配置文件两部分组成，其中配置文件必须放在assets/metadata中")]),t._v(" "),a("p",[a("img",{attrs:{src:"http://static.zybuluo.com/jiangch316/4vhnogb62c9abemgbk5uk34e/module_content_android.jpg",alt:"module_content_android.jpg-96kB"}})]),t._v(" "),a("blockquote",[a("p",[t._v("关于module的命名规范：\n1.第三方的外设集成，我们的module的命名一般为device_xxx,例如 集成cfca的签名功能，我们就应该创建模块device_cfca。\n2.pdf、图片浏览、im、崩溃日志记录等非设备访问的代码要独立建立插件，插件名规范如下core_ext_xxx, 如core_ext_pdf。\n3.原则上尽量一个插件代表一个功能，这样有利于后面我们根据需求进行裁剪。\n4.配置文件的命名为fox_extension_插件名.xml，注意不能存在两个同名的配置文件，另外fox_extension的前缀是固定的。")])]),t._v(" "),a("h2",{attrs:{id:"插件类型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#插件类型"}},[t._v("#")]),t._v(" 插件类型")]),t._v(" "),a("p",[t._v("根据功能和范围插件主要分为APlugin/AProyx，Device和Native几类\nIDevice：插件用于调用系统或第三方提供的外设模块，如相机、OCR、二代证等\nINative：则用于集成除外设类之外的原生功能，如定位、网络等.\nAPlugin/AProyx：则用于功能更为复杂的原生功能调用,该类型的插件能监听到APP的各个生命周期和webview的各个事件。尔APlugin和AProxy的差别是，AProxy通过方法放射的形式实现了action->method的映射，而APlugin只能通过实现execute方法来处理不同的action")]),t._v(" "),a("p",[t._v("我们在原生开发的过程中选择优先顺序是INative&IDevice > AProxy->APlugin，也是我们根据功能分类优先选择Native或Device，当两个不合适的情况下才选择AProxy&APlugin。下图是他们之间的关系")]),t._v(" "),a("p",[a("img",{attrs:{src:"http://static.zybuluo.com/jiangch316/iif81k1bf81mzm7gtg1u695w/plugins.png",alt:"plugins.png-35.5kB"}})])])}),[],!1,null,null,null);e.default=i.exports}}]);